# Medivh

[![Build Status](https://travis-ci.org/moyada/medivh.svg?branch=master)](https://travis-ci.org/moyada/medivh)
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/io.github.moyada/medivh/badge.svg)](https://maven-badges.herokuapp.com/maven-central/io.github.moyada/medivh)
[![license](https://img.shields.io/hexpm/l/plug.svg)](https://github.com/moyada/medivh/blob/master/LICENSE)

English | [简体中文](/README_CN)

> A simple, automatic, and flexible method parameter check library for the Java platform.

## Motivation

We often need to check the method parameters, especially in remote invocation.
This library can save time and effort in this respect, modify the syntax tree at `compilation phase` by configure annotations, and add parameter validation to method.

## Features

* Check whether an object is null.

* Check the size range of basic numeric type (such as int and Integer).

* Check whether a string is blank.

* Check the length range of String or array.

* Check the capacity range of Collection or Map.

* Throw an exception or return data when validated is fails.

## Requirements

JDK 1.6 or higher.

JDK 1.8 or higher if validate target is an interface. 

## Quick start

### 1. Adding dependencies 

Using Maven

```
<dependencies>
    <dependency>
        <groupId>io.github.moyada</groupId>
        <artifactId>medivh</artifactId>
        <version>1.3.0</version>
        <scope>provided</scope>
    </dependency>
<dependencies/>
```

Using Gradle

```
dependencies {
  compileOnly 'io.github.moyada:medivh:1.3.0'
}
```

Without build tool, you can download last jar from 
[![release](https://img.shields.io/badge/release-v1.3.0-blue.svg)](https://github.com/moyada/medivh/releases/latest) 
or
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/io.github.moyada/medivh/badge.svg)](https://maven-badges.herokuapp.com/maven-central/io.github.moyada/medivh)
.

### 2. Use annotation in your program

<font size=5>**Annotation usage**</font>

| Annotation | Application Scope | Effect |
| :---- | :----- | :---- |
| [@NotNull](#NotNull) | field, parameter-less method, method parameter | provide null-check for object type, it is turned on when any rules are used. |
| [@Nullable](#Nullable) | field, parameter-less method, method parameter | do not null-check. |
| [@NotBlank](#NotBlank) | field, parameter-less method, method parameter | provide blank string check rule for String type. |
| [@Min](#NumberRule) | field, parameter-less method, method parameter | provide minimum validation rule for integral number (such as int and Integer). |
| [@Max](#NumberRule) | field, parameter-less method, method parameter | provide maximum validation rule for integral number (such as int and Integer). |
| [@DecimalMin](#NumberRule) | field, parameter-less method, method parameter | provide minimum validation rule for floating-point number (such as double and Double). |
| [@DecimalMax](#NumberRule) | field, parameter-less method, method parameter | provide maximum validation rule for floating-point number (such as double and Double). |
| [@Size](#Size) | field, parameter-less method, method parameter | provide size or length validation rule for String, array, Collection and Map. |
| [@Throw](#Throw) | class, non-abstract method, method parameter | define thrown exception when method parameters is invalid. |
| [@Return](#Return) | non-abstract method, method parameter | define return data when method parameters is invalid, support null, object and basic type. |
| [@Exclusive](#Inheritance) | non-abstract method, method parameter | disable validation logic. |
| [@Variable](#NotNull) | class, method | modify the name of the variable or method generated by validation logic. |

* The annotations design reference Bean Validation 2.0 ([JSR-380](https://jcp.org/en/jsr/detail?id=380))

[Here](#Examples) are some examples.

### 3. Compile project

Use compile commands of build tool, such as `mvn compile` or `gradle build`.
 
Or use java compile command, such as `javac -cp medivh.jar MyApp.java`.

After compilation phase, the class file that configures the rule will create a `validation` method that provide to method validation logic, 
and methods that require parameter verify will add validation logic in front of the method body.

## Configuration options

| Property | Effect |
| :--- | :--- |
| medivh.method | configure the name of default validation method, default is `invalid0` . |
| medivh.var | configure the name of default local variable, default is `mvar_0` . |
| medivh.message | configure the default message head of exception, default is `Invalid input parameter` . |
| medivh.info.null | configure the default info of null check, default is `is null` . |
| medivh.info.equals | configure the default info of equals check, default is `cannot equals` . |
| medivh.info.less | configure the default info of less validate, default is `less than` . |
| medivh.info.great | configure the default info of great validate, default is `great than` . |
| medivh.info.blank | configure the default info of blank check, default is `is blank` . |
| medivh.method.blank | define the method for blank check，format is `<package>.<className>.<methodName>` , not specified will select a public class to create this method. |


## Examples

### Custom Bean Validation

#### NumberRule

| Annotation | Application Scope | Effect |
| :---- | :----- | :---- |
| @Min | field, parameter-less method, method parameter | provide minimum validation rule for integral number (such as int and Integer). |
| @Max | field, parameter-less method, method parameter | provide maximum validation rule for integral number (such as int and Integer). |
| @DecimalMin | field, parameter-less method, method parameter | provide minimum validation rule for floating-point number (such as double and Double). |
| @DecimalMax | field, parameter-less method, method parameter | provide maximum validation rule for floating-point number (such as double and Double). |


```
import io.moyada.medivh.annotation.DecimalMax;
import io.moyada.medivh.annotation.DecimalMin;
import io.moyada.medivh.annotation.Max;
import io.moyada.medivh.annotation.Min;

public class Counter {

    @Min(0)
    private int count;

    @DecimalMin(0.0)
    @DecimalMax(0.75)
    private float loadFactor;

    @DecimalMin(-20.5)
    @Max(100)
    private Double lastest;

    @Min(1)
    @Max(1)
    private byte type;
}
```

The compiled `validation` method will be:

```
public String invalid0() {
    if (this.count < 0) {
        return "count less than 0";
    } else if (this.lastest == null) {
        return "lastest is null";
    } else if (this.lastest > 100.0D) {
        return "lastest great than 100.0";
    } else if (this.lastest < -20.5D) {
        return "lastest less than -20.5";
    } else if (this.loadFactor > 0.75F) {
        return "loadFactor great than 0.75";
    } else if (this.loadFactor < 0.0F) {
        return "loadFactor less than 0.0";
    } else {
        return this.type != 1 ? "type cannot equals 1" : null;
    }
}
```

#### @Size

| Application Scope | Effect |
| :---- | :----- |
| field, parameter-less method, method parameter | provide size or length validation rule for String, array, Collection and Map. |

Attribute Description

| Name | Type | Effect |
| :--- | :--- | :--- |
| min() | int | set the minimum allowed length or capacity. |
| max() | int | set the maximum allowed length or capacity. |

```
import io.moyada.medivh.annotation.Size;

public class Capacity {

    public Capacity() {
    }

    public Capacity(String type, boolean counters) {
        this.type = type;
    }

    @Size(min = 1, max = 50)
    private String type;

    @Size(max = 13)
    private byte[] getTypes() {
        return new byte[0];
    }

    @Size(min = 2)
    private List<Counter> counters;

    @Size(min = 10, max = 10)
    public Map<String, Integer> getEntry() {
        return new HashMap<String, Integer>();
    }
}
```

The compiled `validation` method will be:

```
public String invalid0() {
    byte[] getTypes = this.getTypes();
    if (getTypes == null) {
        return "getTypes is null";
    } else if (getTypes.length > 13) {
        return "getTypes.length great than 13";
    } else if (this.counters == null) {
        return "counters is null";
    } else if (this.counters.size() < 2) {
        return "counters.size() less than 2";
    } else if (this.type == null) {
        return "type is null";
    } else {
        int var$3 = this.type.length();
        if (var$3 > 50) {
            return "type.length() great than 50";
        } else if (var$3 < 1) {
            return "type.length() less than 1";
        } else {
            Map<String, Integer> getEntry = this.getEntry();
            if (getEntry == null) {
                return "getEntry is null";
            } else {
                return getEntry.size() != 10 ? "getEntry cannot equals 10" : null;
            }
        }
    }
}
```

#### @NotBlank

| Application Scope | Effect |
| :---- | :----- |
| field, parameter-less method, method parameter | provide blank string check rule for String type. |


```
import io.moyada.medivh.annotation.NotBlank;

public abstract class Person {

    @NotBlank
    public abstract String getName();

    @NotBlank
    public abstract StringBuffer getAddress();
}
```

The compiled `validation` method will be:

```
public String invalid0() {
    StringBuffer getAddress = this.getAddress();
    if (getAddress == null) {
        return "getAddress is null";
    } else if (isBlank(getAddress)) {
        return "getAddress is blank";
    } else {
        String getName = this.getName();
        if (getName == null) {
            return "getName is null";
        } else {
            return isBlank(getName) ? "getName is blank" : null;
        }
    }
}

public static boolean isBlank(String str) {
    int length = str.length();
    if (length == 0) {
        return true;
    } else {
        for(int i = 0; i < length; ++i) {
            char ch = str.charAt(i);
            if (ch != ' ') {
                return false;
            }
        }

        return true;
    }
}
```

#### @NotNull

| Application Scope | Effect |
| :---- | :----- |
| field, parameter-less method, method parameter | provide null-check for object type, it is turned on when any rules are used. |


```
import io.moyada.medivh.annotation.NotNull;
import io.moyada.medivh.annotation.Variable;

@Variable("check0")
public class Param {

    @NotNull
    private String name;

    @NotNull
    private Object value;
}
```

The compiled `validation` method will be:

```
public String check0() {
    if (this.value == null) {
        return "value is null";
    } else {
        return this.name == null ? "name is null" : null;
    }
}
```

#### @Nullable

| Application Scope | Effect |
| :---- | :----- |
| field, parameter-less method, method parameter | do not null-check. |


```
import io.moyada.medivh.annotation.Nullable;

public interface Product {

    @Nullable
    @Min(-5)
    @Max(80)
    long getId();

    String getName();

    @Nullable
    @NotBlank
    String getType();

    @Nullable
    @Size(min = 1, max = 10)
    List<Capacity> getStore();
}
```

The compiled `validation` method will be:

```
default String invalid0() {
    String getType = this.getType();
    if (getType != null && CaseReturn.isBlank(getType)) {
        return "getType is blank";
    } else {
        long getId = this.getId();
        if (getId > 80L) {
            return "getId great than 80";
        } else if (getId < -5L) {
            return "getId less than -5";
        } else {
            List<Capacity> getStore = this.getStore();
            if (getStore != null) {
                int var$3 = getStore.size();
                if (var$3 > 10) {
                    return "getStore.size() great than 10";
                }

                if (var$3 < 1) {
                    return "getStore.size() less than 1";
                }
            }

            return null;
        }
    }
}
```

### Configure Method Validation

#### @Throw

| Application Scope | Effect |
| :---- | :----- |
| class, non-abstract method, method parameter | define thrown exception when method parameters is invalid. |


Attribute Description

| Name | Type | Effect |
| :--- | :--- | :--- |
| value() | Class | configure thrown exception, the exception type must have a String constructor, default is `IllegalArgumentException` . |
| message() | String | modify the message head of thrown exception. |

```
import io.moyada.medivh.annotation.Throw;

public class CaseThrow {

    public boolean hasReturn(@Throw @NotNull String name,
                             @Throw(NumberFormatException.class) @Min(0) double price,
                             boolean putaway) {
        System.out.println("hasReturn");
        return true;
    }

    public void nonReturn(@Throw(value = IllegalStateException.class, message = "unknown error") Product product,
                          @Throw(message = "price error") @Size(min = 1, max = 20) List<String> param) {
        System.out.println("nonReturn");
    }
}
```

The compiled methods is as follows: 

```
public boolean hasReturn(String name, double price, boolean putaway) {
    if (name == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause name is null");
    } else if (price < 0.0D) {
        throw new NumberFormatException("Invalid input parameter, cause price less than 0.0");
    } else {
        System.out.println("hasReturn");
        return true;
    }
}

public void nonReturn(Product product, List<String> param) {
    if (product == null) {
        throw new IllegalStateException("unknown error, cause product is null");
    } else {
        String mvar_0 = product.invalid0();
        if (mvar_0 != null) {
            throw new IllegalStateException("unknown error, cause " + mvar_0);
        } else if (param == null) {
            throw new IllegalArgumentException("price error, cause param is null");
        } else {
            int var$3 = param.size();
            if (var$3 > 20) {
                throw new IllegalArgumentException("price error, cause param.size() great than 20");
            } else if (var$3 < 1) {
                throw new IllegalArgumentException("price error, cause param.size() less than 1");
            } else {
                System.out.println("nonReturn");
            }
        }
    }
}
```

#### @Return

| Application Scope | Effect |
| :---- | :----- |
| non-abstract method, method parameter | define return data when method parameters is invalid, support null, object and basic type. |


Attribute Description

| Name | Type | Effect |
| :--- | :--- | :--- |
| type() | Class | configure the type of data returned, this type must be subclasses or implementation classes of the method return type. |
| staticMethod() | String | use static method to create return data. |
| value() | Array of String | set the return data, need to have a correspond constructor when return type is object. |

```
import io.moyada.medivh.annotation.Return;

public class CaseReturn {

    public boolean returnPrimitive(@Return("false") @NotNull String name,
                                   @Return("true") @DecimalMin(0.5) double price,
                                   boolean putaway) {
        System.out.println("returnPrimitive");
        return true;
    }

    public Integer returnBasic(@Return("0") Product product,
                               @Throw(message = "null") @Size(min = 1) List<String> param) {
        System.out.println("returnBasic");
        return -1;
    }

    public Capacity returnObject(@Return({"test", "true"})  @NotNull String name,
                                 @Return @Min(0) Byte type) {
        System.out.println("returnObject");
        return new Capacity();
    }

    public Product returnInterface(@Return(type = Item.class) @NotBlank String name) {
        System.out.println("returnInterface");
        return null;
    }

    public Product useStaticMethod(@Return(type = CaseReturn.class, staticMethod = "getProduct") @Size(min = 3) String name,
                                   @Return(value = "test", type = CaseReturn.class, staticMethod = "getProduct") @NotNull Integer id) {
        System.out.println("useStaticMethod");
        return null;
    }

    public static Product getProduct() {
        return new Item();
    }

    public static Product getProduct(String name) {
        return new Item(name);
    }

    static class Item implements Product {

        ...
    }
}
```

The compiled methods is as follows: 

```
public boolean returnPrimitive(String name, double price, boolean putaway) {
    if (name == null) {
        return false;
    } else if (price < 0.5D) {
        return true;
    } else {
        System.out.println("returnPrimitive");
        return true;
    }
}

public Integer returnBasic(Product product, List<String> param) {
    if (product == null) {
        return 0;
    } else {
        String mvar_0 = product.invalid0();
        if (mvar_0 != null) {
            return 0;
        } else if (param == null) {
            throw new IllegalArgumentException("null, cause param is null");
        } else if (param.size() < 1) {
            throw new IllegalArgumentException("null, cause param.size() less than 1");
        } else {
            System.out.println("returnBasic");
            return -1;
        }
    }
}

public Capacity returnObject(String name, Byte type) {
    if (name == null) {
        return new Capacity("test", true);
    } else if (type == null) {
        return new Capacity();
    } else if (type < 0) {
        return new Capacity();
    } else {
        System.out.println("returnObject");
        return new Capacity();
    }
}

public Product returnInterface(String name) {
    if (name == null) {
        return new CaseReturn.Item();
    } else if (isBlank(name)) {
        return new CaseReturn.Item();
    } else {
        System.out.println("returnInterface");
        return null;
    }
}

public Product useStaticMethod(String name, Integer id) {
    if (name == null) {
        return getProduct();
    } else if (name.length() < 3) {
        return getProduct();
    } else if (id == null) {
        return getProduct("test");
    } else {
        System.out.println("useStaticMethod");
        return null;
    }
}
```

#### Mixed Use

```
public class CaseCombine {

    public boolean returnPrimitive(@Return("false") Product product,
                                   @Throw Counter price) {
        System.out.println("returnPrimitive");
        return true;
    }

    public Product returnObject(@Throw Person person,
                                @Return(type = CaseReturn.Item.class) @NotBlank String name,
                                @Return(type = CaseReturn.class, staticMethod = "getProduct") Capacity capacity) {
        System.out.println("returnPrimitive");
        return null;
    }
}
```

The compiled methods is as follows: 

```
public boolean returnPrimitive(Product product, Counter price) {
    if (product == null) {
        return false;
    } else {
        String mvar_0 = product.invalid0();
        if (mvar_0 != null) {
            return false;
        } else if (price == null) {
            throw new IllegalArgumentException("Invalid input parameter, cause price is null");
        } else {
            mvar_0 = price.invalid0();
            if (mvar_0 != null) {
                throw new IllegalArgumentException("Invalid input parameter, cause " + mvar_0);
            } else {
                System.out.println("returnPrimitive");
                return true;
            }
        }
    }
}

public Product returnObject(Person person, String name, Capacity capacity) {
    if (person == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause person is null");
    } else {
        String mvar_0 = person.invalid0();
        if (mvar_0 != null) {
            throw new IllegalArgumentException("Invalid input parameter, cause " + mvar_0);
        } else if (name == null) {
            return new Item();
        } else if (CaseReturn.isBlank(name)) {
            return new Item();
        } else if (capacity == null) {
            return CaseReturn.getProduct();
        } else {
            mvar_0 = capacity.invalid0();
            if (mvar_0 != null) {
                return CaseReturn.getProduct();
            } else {
                System.out.println("returnPrimitive");
                return null;
            }
        }
    }
}
```

#### Inheritance

```
import io.moyada.medivh.annotation.Exclusive;

@Throw
public class CaseInherit {

    public boolean customRule(Product product, Capacity capacity) {
        System.out.println("customRule");
        return true;
    }

    @Return({"test", "true"})
    public Capacity useReturn(@NotBlank String name,
                              @Throw Counter counter) {
        System.out.println("useReturn");
        return null;
    }

    @Variable("tmp0")
    @Throw(value = UnsupportedOperationException.class)
    public void excludeParam(@Exclusive Product product,
                             @Size(min = 5) int[] ids) {
        System.out.println("excludeParam");
    }

    @Exclusive
    public int excludeMethod(@Return("-1") Product product) {
        return 0;
    }
}
```

The compiled methods is as follows: 

```
public boolean customRule(Product product, Capacity capacity) {
    if (product == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause product is null");
    } else {
        String mvar_0 = product.invalid0();
        if (mvar_0 != null) {
            throw new IllegalArgumentException("Invalid input parameter, cause " + mvar_0);
        } else if (capacity == null) {
            throw new IllegalArgumentException("Invalid input parameter, cause capacity is null");
        } else {
            mvar_0 = capacity.invalid0();
            if (mvar_0 != null) {
                throw new IllegalArgumentException("Invalid input parameter, cause " + mvar_0);
            } else {
                System.out.println("customRule");
                return true;
            }
        }
    }
}

public Capacity useReturn(String name, Counter counter) {
    if (name == null) {
        return new Capacity("test", true);
    } else if (CaseReturn.isBlank(name)) {
        return new Capacity("test", true);
    } else if (counter == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause counter is null");
    } else {
        String mvar_0 = counter.invalid0();
        if (mvar_0 != null) {
            throw new IllegalArgumentException("Invalid input parameter, cause " + mvar_0);
        } else {
            System.out.println("useReturn");
            return null;
        }
    }
}

public void excludeParam(Product product, int[] ids) {
    if (ids == null) {
        throw new UnsupportedOperationException("Invalid input parameter, cause ids is null");
    } else if (ids.length < 5) {
        throw new UnsupportedOperationException("Invalid input parameter, cause ids.length less than 5");
    } else {
        System.out.println("excludeParam");
    }
}

public int excludeMethod(Product product) {
    return 0;
}
```


