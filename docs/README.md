# Medivh

[![Build Status](https://travis-ci.org/moyada/medivh.svg?branch=master)](https://travis-ci.org/moyada/medivh)
![java lifecycle](https://img.shields.io/badge/java%20lifecycle-compilation-red.svg)
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/io.github.moyada/medivh/badge.svg)](https://maven-badges.herokuapp.com/maven-central/io.github.moyada/medivh)
[![license](https://img.shields.io/hexpm/l/plug.svg)](https://github.com/moyada/medivh/blob/master/LICENSE)

English | [简体中文](/README_CN)

Medivh is a Java annotation processor for automatically generate method parameter validation.

## Motivation

We often need to check the method parameters, especially in remote invocation.
This library can save time and effort in this respect, modify the syntax tree at `compilation phase` by configure annotations, add parameter validation to method.

## Features

* Check whether an object is null.

* Check the size range of basic numeric type (such as int and Integer).

* Check whether a string is blank.

* Check the length range of String or array.

* Check the capacity range of Collection or Map.

* Throw an exception or return data when validated is failed.

## Requirements

JDK 1.6 or higher.

JDK 1.8 or higher if validate target is an interface. 

## Quick start

### 1. Adding dependencies 

Using Maven

```
<dependencies>
    <dependency>
        <groupId>io.github.moyada</groupId>
        <artifactId>medivh</artifactId>
        <version>1.2.1</version>
        <scope>provided</scope>
    </dependency>
<dependencies/>
```

Using Gradle

```
dependencies {
  compileOnly 'io.github.moyada:medivh:1.2.1'
}
```

Without build tool, you can download last jar from 
[![release](https://img.shields.io/badge/release-v1.2.1-blue.svg)](https://github.com/moyada/medivh/releases/latest) 
or
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/io.github.moyada/medivh/badge.svg)](https://maven-badges.herokuapp.com/maven-central/io.github.moyada/medivh)
.

### 2. Use annotation in you programming

Annotation usage

| Annotation | Application Scope | Effect |
| :---- | :----- | :---- |
| @NotNull | field, parameter-less method, method parameter | provide null-check for object type, it is turned on when any rules are used. |
| @Nullable | field, parameter-less method, method parameter | do not null-check. |
| @NotBlank | field, parameter-less method, method parameter | provide blank string check rule for String type. |
| @SizeRule | field, parameter-less method, method parameter | provide size or length validation rule for String, array, Collection and Map. |
| @NumberRule | field, parameter-less method, method parameter | provide size range validation rule for basic numeric type (such as int and Integer). |
| @Throw | class, non-abstract method, method parameter | define thrown exception when method parameters is invalid. |
| @Return | non-abstract method, method parameter | define return data when method parameters is invalid, support null, object and basic type. |
| @Exclusive | non-abstract method, method parameter | disable validation logic. |
| @Variable | class, method | modify the name of the variable or method generated by validation logic. |

[Here](#Examples) are some examples.

### 3. Compile project

Use compile commands of build tool, such as `mvn compile` or `gradle build`.
 
Or use java compile command, such as `javac -cp medivh.jar MyApp.java`.

After compilation phase, the validation logic will be generated.

## Configuration option

| Property | Effect |
| :--- | :--- |
| medivh.method | configure the name of default validation method, default is `invalid0` . |
| medivh.var | configure the name of default local variable, default is `mvar_0` . |
| medivh.message | configure the default message head of exception, default is `Invalid input parameter` . |
| medivh.info.null | configure the default info of null check, default is `is null` . |
| medivh.info.equals | configure the default info of equals check, default is `cannot equals` . |
| medivh.info.less | configure the default info of less validate, default is `less than` . |
| medivh.info.great | configure the default info of great validate, default is `great than` . |
| medivh.info.blank | configure the default info of blank check, default is `is blank` . |
| medivh.method.blank | define the method for blank check，format is `<package>.<className>.<methodName>` , not specified will select a public class to create this method. |


## Examples

### Custom Object Validation

#### @NumberRule

| Application Scope | Effect |
| :---- | :----- |
| field, parameter-less method, method parameter | provide size range validation rule for basic numeric type (such as int and Integer). |

Attribute Description

| Name | Type | Effect |
| :--- | :--- | :--- |
| min() | String | set the minimum allowed value. |
| max() | String | set the maximum allowed value. |

```
public class Counter {

    @NumberRule(min = "0", max = "1000")
    private int count;

    @NumberRule(min = "-20.5", max = "100")
    private Double lastest;

    @NumberRule(min = "1", max = "1")
    private byte type;
}
```

The compiled verification method will be:

```
public String invalid0() {
    if (this.lastest == null) {
        return "lastest is null";
    } else if (this.lastest > 100.0D) {
        return "lastest great than 100.0";
    } else if (this.type != 1) {
        return "type cannot equals 1";
    } else {
        int var$3 = this.count;
        if (var$3 > 1000) {
            return "count great than 1000";
        } else {
            return var$3 < 0 ? "count less than 0" : null;
        }
    }
}
```

#### @SizeRule

| Application Scope | Effect |
| :---- | :----- |
| field, parameter-less method, method parameter | provide size or length validation rule for String, array, Collection and Map. |

Attribute Description

| Name | Type | Effect |
| :--- | :--- | :--- |
| min() | int | set the minimum allowed length or capacity. |
| max() | int | set the maximum allowed length or capacity. |

```
public class Capacity {

    public Capacity() {
    }

    public Capacity(String type, boolean counters) {
        this.type = type;
    }

    @SizeRule(min = 0, max = 50)
    private String type;

    @SizeRule(min = 1)
    private byte[] getTypes() {
        return new byte[0];
    }

    @SizeRule(max = 200)
    private List<Counter> counters;

    @SizeRule(min = 10, max = 10)
    public Map<String, Integer> getEntry() {
        return new HashMap<String, Integer>();
    }
}
```

The compiled verification method will be:

```
public String invalid0() {
    Map<String, Integer> getEntry = this.getEntry();
    if (getEntry == null) {
        return "getEntry is null";
    } else if (getEntry.size() != 10) {
        return "getEntry cannot equals 10";
    } else {
        byte[] getTypes = this.getTypes();
        if (getTypes == null) {
            return "getTypes is null";
        } else if (getTypes.length < 1) {
            return "getTypes.length less than 1";
        } else if (this.type == null) {
            return "type is null";
        } else {
            int var$3 = this.type.length();
            if (var$3 > 50) {
                return "type.length() great than 50";
            } else if (var$3 < 0) {
                return "type.length() less than 0";
            } else if (this.counters == null) {
                return "counters is null";
            } else {
                return this.counters.size() > 200 ? "counters.size() great than 200" : null;
            }
        }
    }
}
```

#### @NotBlank

| Application Scope | Effect |
| :---- | :----- |
| field, parameter-less method, method parameter | provide blank string check rule for String type. |


```
public abstract class Person {

    @NotBlank
    public abstract String getName();
}
```

The compiled verification method will be:

```
public String invalid0() {
    String getName = this.getName();
    if (getName == null) {
        return "getName is null";
    } else {
        return isBlank(getName) ? "getName is blank" : null;
    }
}

public static boolean isBlank(String str) {
    int length = str.length();
    if (length == 0) {
        return true;
    } else {
        for(int i = 0; i < length; ++i) {
            char ch = str.charAt(i);
            if (ch != ' ') {
                return false;
            }
        }

        return true;
    }
}
```

#### @NotNull

| Application Scope | Effect |
| :---- | :----- |
| field, parameter-less method, method parameter | provide null-check for object type, it is turned on when any rules are used. |


```
@Variable("check0")
public class Param {

    @NotNull
    private String name;

    @NotNull
    private Object value;
}
```

The compiled verification method will be:

```
public String check0() {
    if (this.value == null) {
        return "value is null";
    } else {
        return this.name == null ? "name is null" : null;
    }
}
```

#### @Nullable

| Application Scope | Effect |
| :---- | :----- |
| field, parameter-less method, method parameter | do not null-check. |


```
public interface Product {

    String getName();

    @Nullable
    @NotBlank
    String getType();

    @Nullable
    @SizeRule(min = 0)
    List<Capacity> getStore();
}
```

The compiled verification method will be:

```
default String invalid0() {
    List<Capacity> getStore = this.getStore();
    if (getStore != null && getStore.size() < 0) {
        return "getStore.size() less than 0";
    } else {
        String getName = this.getType();
        if (getName != null && Person.isBlank(getName)) {
            return "getType is blank";
        } else {
            getName = this.getName();
            return getName == null ? "getName is null" : null;
        }
    }
}
```

### Configure Method Validation

#### @Throw

| Application Scope | Effect |
| :---- | :----- |
| class, non-abstract method, method parameter | define thrown exception when method parameters is invalid. |


Attribute Description

| Name | Type | Effect |
| :--- | :--- | :--- |
| value() | Class | configure thrown exception, the exception type must have a String constructor, default is `IllegalArgumentException` . |
| message() | String | modify the message head of thrown exception. |

```
public class CaseThrow {

    public boolean hasReturn(@Throw @NotNull String name,
                             @Throw(NumberFormatException.class) @NumberRule(min = "0.0") double price,
                             boolean putaway) {
        System.out.println(name);
        System.out.println(price);
        System.out.println(putaway);
        return true;
    }

    public void nonReturn(@Throw Product product,
                          @Throw(message = "price error") @NumberRule(min = "0.0") Double price) {
        System.out.println(product);
        System.out.println(price);
    }
}
```

The compiled methods is as follows: 

```
public boolean hasReturn(String name, double price, boolean putaway) {
    if (name == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause name is null");
    } else if (price < 0.0D) {
        throw new NumberFormatException("Invalid input parameter, cause price less than 0.0");
    } else {
        System.out.println(name);
        System.out.println(price);
        System.out.println(putaway);
        return true;
    }
}

public void nonReturn(Product product, Double price) {
    if (product == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause product is null");
    } else {
        String mvar_0 = product.invalid0();
        if (mvar_0 != null) {
            throw new IllegalArgumentException("Invalid input parameter, cause " + mvar_0);
        } else if (price == null) {
            throw new IllegalArgumentException("price error, cause price is null");
        } else if (price < 0.0D) {
            throw new IllegalArgumentException("price error, cause price less than 0.0");
        } else {
            System.out.println(product);
            System.out.println(price);
        }
    }
}
```

#### @Return

| Application Scope | Effect |
| :---- | :----- |
| non-abstract method, method parameter | define return data when method parameters is invalid, support null, object and basic type. |


Attribute Description

| Name | Type | Effect |
| :--- | :--- | :--- |
| type() | Class | configure the type of data returned, this type must be subclasses or implementation classes of the method return type. |
| staticMethod() | String | use static method to create return data. |
| value() | Array of String | set the return data, need to have a correspond constructor when return type is object. |

```
public class CaseReturn {

    public boolean returnPrimitive(@Return("false") @NotNull String name,
                                   Double price) {
        System.out.println(name);
        System.out.println(price);
        return true;
    }

    public Integer returnBasic(@Return("0") @NumberRule(min = "0") Double price) {
        return null;
    }

    public Capacity returnObject(@Return("null") @NotBlank String name,
                                 @Return({"test", "true"}) @NumberRule(min = "0") byte type) {
        return new Capacity();
    }

    public Product returnInterface(@Return(type = Item.class) @NotBlank String name) {
        return null;
    }

    public Product useStaticMethod(@Return(type = CaseReturn.class, staticMethod = "getProduct") @NotBlank String name,
                                   @Return(value = "test", type = CaseReturn.class, staticMethod = "getProduct") @NotNull Integer id) {
        return null;
    }

    public static Product getProduct() {
        return new Item();
    }

    public static Product getProduct(String name) {
        return new Item(name);
    }

    static class Item implements Product {

        private String name;

        public Item() {
        }

        public Item(String name) {
            this.name = name;
        }

        @Override
        public String getName() {
            return null;
        }

        @Override
        public String getType() {
            return null;
        }

        @Override
        public List<Capacity> getStore() {
            return null;
        }
    }
}
```

The compiled methods is as follows: 

```
public boolean returnPrimitive(String name, Double price) {
    if (name == null) {
        return false;
    } else {
        System.out.println(name);
        System.out.println(price);
        return true;
    }
}

public Integer returnBasic(Double price) {
    if (price == null) {
        return 0;
    } else {
        return price < 0.0D ? 0 : null;
    }
}

public Capacity returnObject(String name, byte type) {
    if (name == null) {
        return null;
    } else if (Persion.isBlank(name)) {
        return null;
    } else {
        return type < 0 ? new Capacity("test", true) : new Capacity();
    }
}

public Product returnInterface(String name) {
    if (name == null) {
        return new CaseReturn.Item();
    } else {
        return Persion.isBlank(name) ? new CaseReturn.Item() : null;
    }
}

public Product useStaticMethod(String name, Integer id) {
    if (name == null) {
        return getProduct();
    } else if (Persion.isBlank(name)) {
        return getProduct();
    } else {
        return id == null ? getProduct("test") : null;
    }
}
```

#### Combine Use
```
public class CaseCombine {

    public boolean returnPrimitive(@Return("false") @NotNull String name,
                                   @Throw @NumberRule(min = "0") Double price) {
        System.out.println(name);
        System.out.println(price);
        return true;
    }

    public Capacity returnObject(@Return("null") @NotBlank String name,
                                 @Throw @NumberRule(min = "0") byte type,
                                 @Return({"null", "false"}) @NotNull Double price) {
        return new Capacity();
    }

    public Product useStaticMethod(@Return(type = CaseReturn.class, staticMethod = "getProduct") @NotBlank String name,
                                   @Throw(value = IllegalStateException.class, message = "id error") @NumberRule(min = "0") Integer id) {
        return null;
    }
}
```

The compiled methods is as follows: 

```
public boolean returnPrimitive(String name, Double price) {
    if (name == null) {
        return false;
    } else if (price == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause price is null");
    } else if (price < 0.0D) {
        throw new IllegalArgumentException("Invalid input parameter, cause price less than 0.0");
    } else {
        System.out.println(name);
        System.out.println(price);
        return true;
    }
}

public Capacity returnObject(String name, byte type, Double price) {
    if (name == null) {
        return null;
    } else if (Persion.isBlank(name)) {
        return null;
    } else if (type < 0) {
        throw new IllegalArgumentException("Invalid input parameter, cause type less than 0");
    } else {
        return price == null ? new Capacity((String)null, false) : new Capacity();
    }
}

public Product useStaticMethod(String name, Integer id) {
    if (name == null) {
        return CaseReturn.getProduct();
    } else if (Persion.isBlank(name)) {
        return CaseReturn.getProduct();
    } else if (id == null) {
        throw new IllegalStateException("id error, cause id is null");
    } else if (id < 0) {
        throw new IllegalStateException("id error, cause id less than 0");
    } else {
        return null;
    }
}
```

#### Inherit Use

```
@Throw
public class CaseInherit {

    public boolean save(@NotNull String name,
                        @Throw(NumberFormatException.class) @NumberRule(min = "0.0") double price,
                        boolean putaway) {
        System.out.println(name);
        System.out.println(price);
        System.out.println(putaway);
        return true;
    }

    @Return("null")
    public Capacity get(@NotBlank String name,
                        @Return({"test", "true"}) @NumberRule(min = "0") byte type) {
        return new Capacity();
    }

    @Variable("tmp0")
    @Throw(value = IllegalStateException.class, message = "price error")
    public void update(Product product,
                       @NumberRule(min = "0.0") Double price) {
        System.out.println(product);
        System.out.println(price);
    }

    public boolean exist(Product product) {
        return true;
    }

    @Exclusive
    public int count(Product product) {
        return 1000;
    }

    public int check(@NotNull String name,
                     @Exclusive Product product) {
        return 1000;
    }
}
```

The compiled methods is as follows: 

```
public boolean save(String name, double price, boolean putaway) {
    if (name == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause name is null");
    } else if (price < 0.0D) {
        throw new NumberFormatException("Invalid input parameter, cause price less than 0.0");
    } else {
        System.out.println(name);
        System.out.println(price);
        System.out.println(putaway);
        return true;
    }
}

public Capacity get(String name, byte type) {
    if (name == null) {
        return null;
    } else if (Persion.isBlank(name)) {
        return null;
    } else {
        return type < 0 ? new Capacity("test", true) : new Capacity();
    }
}

public void update(Product product, Double price) {
    if (product == null) {
        throw new IllegalStateException("price error, cause product is null");
    } else {
        String tmp0 = product.invalid0();
        if (tmp0 != null) {
            throw new IllegalStateException("price error, cause " + tmp0);
        } else if (price == null) {
            throw new IllegalStateException("price error, cause price is null");
        } else if (price < 0.0D) {
            throw new IllegalStateException("price error, cause price less than 0.0");
        } else {
            System.out.println(product);
            System.out.println(price);
        }
    }
}

public boolean exist(Product product) {
    if (product == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause product is null");
    } else {
        String mvar_0 = product.invalid0();
        if (mvar_0 != null) {
            throw new IllegalArgumentException("Invalid input parameter, cause " + mvar_0);
        } else {
            return true;
        }
    }
}

public int count(Product product) {
    return 1000;
}

public int check(String name, Product product) {
    if (name == null) {
        throw new IllegalArgumentException("Invalid input parameter, cause name is null");
    } else {
        return 1000;
    }
}
```


